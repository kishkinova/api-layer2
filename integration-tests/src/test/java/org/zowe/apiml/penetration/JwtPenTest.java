package org.zowe.apiml.penetration;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.restassured.RestAssured;
import org.junit.Before;
import org.junit.Test;
import org.zowe.apiml.gatewayservice.SecurityUtils;
import org.zowe.apiml.security.HttpsConfig;
import org.zowe.apiml.util.config.ConfigReader;
import org.zowe.apiml.util.config.TlsConfiguration;

import java.nio.charset.StandardCharsets;
import java.security.PublicKey;
import java.util.Base64;

import static io.restassured.RestAssured.given;
import static org.apache.http.HttpStatus.SC_UNAUTHORIZED;
import static org.hamcrest.core.Is.is;
import static org.zowe.apiml.security.SecurityUtils.loadPublicKey;

/*
 * Penetration testing of JWT
 *
 * Based on the following article:
 * https://medium.com/101-writeups/hacking-json-web-token-jwt-233fe6c862e6
 */
public class JwtPenTest {
    private final static String SCHEME = ConfigReader.environmentConfiguration().getGatewayServiceConfiguration().getScheme();
    private final static String HOST = ConfigReader.environmentConfiguration().getGatewayServiceConfiguration().getHost();
    private final static int PORT = ConfigReader.environmentConfiguration().getGatewayServiceConfiguration().getPort();
    private final static String BASE_PATH = "/api/v1/gateway";
    private final static String QUERY_ENDPOINT = "/auth/query";
    private final static String PASSWORD = ConfigReader.environmentConfiguration().getCredentials().getPassword();
    private final static String USERNAME = ConfigReader.environmentConfiguration().getCredentials().getUser();

    private String token;

    @Before
    public void setUp() {
        RestAssured.port = PORT;
        RestAssured.basePath = BASE_PATH;
        RestAssured.useRelaxedHTTPSValidation();

        token = SecurityUtils.gatewayToken(USERNAME, PASSWORD);
    }

    @Test
    public void sendJwtWithoutSignature() {
        String noneHeader = "eyJhbGciOiJub25lIn0";
        String payload = getPayload(token);

        String newToken = String.format("%s.%s.", noneHeader, payload);

        //@formatter:off
        given()
            .header("Authorization", "Bearer " + newToken)
        .when()
            .get(String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, QUERY_ENDPOINT))
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void changeCipherToSymmetric() {
        TlsConfiguration tlsConfiguration = ConfigReader.environmentConfiguration().getTlsConfiguration();
        HttpsConfig config = HttpsConfig.builder()
            .keyAlias(tlsConfiguration.getKeyAlias())
            .keyStore(tlsConfiguration.getKeyStore())
            .keyPassword(tlsConfiguration.getKeyPassword())
            .keyStorePassword(tlsConfiguration.getKeyStorePassword())
            .keyStoreType(tlsConfiguration.getKeyStoreType())
            .build();
        PublicKey publicKey = loadPublicKey(config);
        assert publicKey != null;

        String payload = getPayload(token);
        String decodedPayload = new String(Base64.getDecoder().decode(payload), StandardCharsets.UTF_8);

        String newToken = Jwts.builder()
            .setPayload(decodedPayload)
            .signWith(SignatureAlgorithm.HS256, publicKey.getEncoded())  // Library does not allow me to use public key for signing directly
            .compact();

        //@formatter:off
        given()
            .header("Authorization", "Bearer " + newToken)
        .when()
            .get(String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, QUERY_ENDPOINT))
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void modifyJwtClaim() {
        int indexClaim = token.indexOf('.');
        int indexSign = token.indexOf('.', indexClaim + 1);

        String header = token.substring(0, indexClaim);

        // Modify issuer
        String payload = getPayload(token);
        String decodedPayload = new String(Base64.getDecoder().decode(payload), StandardCharsets.UTF_8);
        int indexIss = decodedPayload.indexOf("iss");
        String modifiedPayload = decodedPayload.substring(0, indexIss + 6) + "x" + decodedPayload.substring(indexIss + 7);
        String newPayload = Base64.getEncoder().encodeToString(modifiedPayload.getBytes());

        String signature = token.substring(indexSign + 1);

        String newToken = String.format("%s.%s.%s", header, newPayload, signature);

        //@formatter:off
        given()
            .header("Authorization", "Bearer " + newToken)
        .when()
            .get(String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, QUERY_ENDPOINT))
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    private String getPayload(String token) {
        int indexClaim = token.indexOf('.');
        int indexSign = token.indexOf('.', indexClaim + 1);

        return token.substring(indexClaim + 1, indexSign);
    }
}
