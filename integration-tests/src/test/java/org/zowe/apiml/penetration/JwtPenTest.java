/*
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright Contributors to the Zowe Project.
 */
package org.zowe.apiml.penetration;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.restassured.RestAssured;
import org.json.JSONObject;
import org.junit.Before;
import org.junit.Test;
import org.zowe.apiml.gatewayservice.SecurityUtils;
import org.zowe.apiml.security.HttpsConfig;
import org.zowe.apiml.security.common.ticket.TicketRequest;
import org.zowe.apiml.util.config.ConfigReader;
import org.zowe.apiml.util.config.EnvironmentConfiguration;
import org.zowe.apiml.util.config.TlsConfiguration;

import java.nio.charset.StandardCharsets;
import java.security.PublicKey;
import java.util.Base64;

import static io.restassured.RestAssured.given;
import static io.restassured.http.ContentType.JSON;
import static org.apache.http.HttpStatus.SC_OK;
import static org.apache.http.HttpStatus.SC_UNAUTHORIZED;
import static org.hamcrest.core.Is.is;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.zowe.apiml.gatewayservice.SecurityUtils.getConfiguredSslConfig;
import static org.zowe.apiml.security.SecurityUtils.loadPublicKey;

/*
 * Penetration testing of JWT
 *
 * Based on the following article:
 * https://medium.com/101-writeups/hacking-json-web-token-jwt-233fe6c862e6
 *
 * It tests three type of endpoints:
 * - query endpoint (verify JWT token)
 * - PassTicket endpoint on Gateway (covered by Spring Security, see authorized access)
 * - PassTicket endpoint on Discoverable client (through server command's treatment)
 *
 * On each type of endpoint are tested those cases:
 * - success (real right-formed JWT)
 * - unauthorized
 *      - token without signature
 *      - token with changed iss (realm)
 *      - token with changed username (sub)
 *      - token signed with public key
 */
public class JwtPenTest {

    private static final EnvironmentConfiguration ENV = ConfigReader.environmentConfiguration();

    private static final String SCHEME = ENV.getGatewayServiceConfiguration().getScheme();
    private static final String HOST = ENV.getGatewayServiceConfiguration().getHost();
    private static final int PORT = ENV.getGatewayServiceConfiguration().getPort();
    private static final String APPLICATION_NAME = ENV.getDiscoverableClientConfiguration().getApplId();
    private static final String USERNAME = ENV.getCredentials().getUser();
    private static final String PASSWORD = ENV.getCredentials().getPassword();
    private static final String COOKIE = "apimlAuthenticationToken";

    private static final String BASE_PATH = "/api/v1/gateway";
    private static final String QUERY_ENDPOINT = "/auth/query";
    private static final String STATICCLIENT_BASE_PATH = "/api/v1/staticclient";
    private static final String PASSTICKET_TEST_ENDPOINT = "/passticketTest";
    private static final String PASSTICKET_ENDPOINT = "/auth/ticket";

    private static final String QUERY_ENDPOINT_URL = String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, QUERY_ENDPOINT);
    private static final String PASSTICKET_ENDPOINT_URL = String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, STATICCLIENT_BASE_PATH, PASSTICKET_TEST_ENDPOINT);
    private static final String GATEWAY_ENDPOINT_URL = String.format("%s://%s:%d%s%s", SCHEME, HOST, PORT, BASE_PATH, PASSTICKET_ENDPOINT);

    private String token;

    @Before
    public void setUp() {
        RestAssured.port = PORT;
        RestAssured.basePath = "/";
        RestAssured.useRelaxedHTTPSValidation();
        RestAssured.config = RestAssured.config().sslConfig(getConfiguredSslConfig());

        token = SecurityUtils.gatewayToken(USERNAME, PASSWORD);
    }

    private String getPart(int index) {
        final String[] parts = token.split("\\.");
        return parts[index];
    }

    private String getHeader() {
        return getPart(0);
    }

    private String getPayload() {
        return getPart(1);
    }

    private String getSignature() {
        return getPart(2);
    }

    private String replaceClaim(String originalPaylad, String name, String value) {
        final String decoded = new String(Base64.getDecoder().decode(originalPaylad), StandardCharsets.UTF_8);
        final JSONObject json = new JSONObject(decoded);
        json.put(name, value);
        return Base64.getEncoder().encodeToString(json.toString().getBytes(StandardCharsets.UTF_8));
    }

    private String getTokenNoneAlgorithm() {
        final JSONObject jsonObject = new JSONObject();
        jsonObject.put("alg", "none");
        final String noneHeader = Base64.getEncoder().encodeToString(jsonObject.toString().getBytes(StandardCharsets.UTF_8));
        return String.format("%s.%s.", noneHeader, getPayload());
    }

    private PublicKey getPublicKey() {
        TlsConfiguration tlsConfiguration = ConfigReader.environmentConfiguration().getTlsConfiguration();
        HttpsConfig config = HttpsConfig.builder()
            .keyAlias(tlsConfiguration.getKeyAlias())
            .keyStore(tlsConfiguration.getKeyStore())
            .keyPassword(tlsConfiguration.getKeyPassword())
            .keyStorePassword(tlsConfiguration.getKeyStorePassword())
            .keyStoreType(tlsConfiguration.getKeyStoreType())
            .build();
        PublicKey publicKey = loadPublicKey(config);
        assertNotNull(publicKey);
        return publicKey;
    }

    private String getTokenWithHs256Signature() {
        PublicKey publicKey = getPublicKey();

        String payload = getPayload();
        String decodedPayload = new String(Base64.getDecoder().decode(payload), StandardCharsets.UTF_8);

        return Jwts.builder()
            .setPayload(decodedPayload)
            .signWith(SignatureAlgorithm.HS256, publicKey.getEncoded())  // Library does not allow me to use public key for signing directly
            .compact();
    }

    private String getTokenChangedRealm() {
        final String newPayload = replaceClaim(getPayload(), "iss", "ThirdParty");
        return String.format("%s.%s.%s", getHeader(), newPayload, getSignature());
    }

    private String getTokenChangedUser() {
        final String newPayload = replaceClaim(getPayload(), "sub", "admin");
        return String.format("%s.%s.%s", getHeader(), newPayload, getSignature());
    }

    @Test
    public void givenRightJwt_thenSuccess_whenCallQueryEndpoint() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get(QUERY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_OK));
        //@formatter:on
    }

    @Test
    public void givenJwtWithNoSign_thenUnauthorized_whenCallQueryEndpoint() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenNoneAlgorithm())
        .when()
            .get(QUERY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtSignedByPublicKey_thenUnauthorized_whenCallQueryEndpoint() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenWithHs256Signature())
        .when()
            .get(QUERY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtWithChangedRealm_thenUnauthorized_whenCallQueryEndpoint() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenChangedRealm())
        .when()
            .get(QUERY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtWithChangedUser_thenUnauthorized_whenCallQueryEndpoint() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenChangedUser())
        .when()
            .get(QUERY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenRightJwt_thenSuccess_whenCallPassTicketService() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + token)
        .when()
            .get(PASSTICKET_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_OK));
        //@formatter:on
    }

    @Test
    public void givenJwtWithNoSign_thenUnauthorized_whenCallPassTicketService() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenNoneAlgorithm())
        .when()
            .get(PASSTICKET_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtSignedByPublicKey_thenUnauthorized_whenCallPassTicketService() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenWithHs256Signature())
        .when()
            .get(PASSTICKET_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtWithChangedRealm_thenUnauthorized_whenCallPassTicketService() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenChangedRealm())
        .when()
            .get(PASSTICKET_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtWithChangedUser_thenUnauthorized_whenCallPassTicketService() {
        //@formatter:off
        given()
            .header("Authorization", "Bearer " + getTokenChangedUser())
        .when()
            .get(PASSTICKET_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenRightJwt_thenSuccess_thenUnauthorized_whenCallPassTicketEndpoint() {
        //@formatter:off
        given()
            .contentType(JSON)
            .header("Authorization", "Bearer " + token)
            .body(new TicketRequest(APPLICATION_NAME))
        .when()
            .post(GATEWAY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_OK));
        //@formatter:on
    }

    @Test
    public void givenJwtWithNoSign_thenUnauthorized_whenCallPassTicketEndpoint() {
        //@formatter:off
        given()
            .contentType(JSON)
            .header("Authorization", "Bearer " + getTokenNoneAlgorithm())
            .body(new TicketRequest(APPLICATION_NAME))
        .when()
            .post(GATEWAY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtSignedByPublicKey_thenUnauthorized_whenCallPassTicketEndpoint() {
        //@formatter:off
        given()
            .contentType(JSON)
            .header("Authorization", "Bearer " + getTokenWithHs256Signature())
            .body(new TicketRequest(APPLICATION_NAME))
        .when()
            .post(GATEWAY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtWithChangedRealm_thenUnauthorized_whenCallPassTicketEndpoint() {
        //@formatter:off
        given()
            .contentType(JSON)
            .header("Authorization", "Bearer " + getTokenChangedRealm())
            .body(new TicketRequest(APPLICATION_NAME))
        .when()
            .post(GATEWAY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

    @Test
    public void givenJwtWithChangedUser_thenUnauthorized_whenCallPassTicketEndpoint() {
        //@formatter:off
        given()
            .contentType(JSON)
            .header("Authorization", "Bearer " + getTokenChangedUser())
            .body(new TicketRequest(APPLICATION_NAME))
        .when()
            .post(GATEWAY_ENDPOINT_URL)
        .then()
            .statusCode(is(SC_UNAUTHORIZED));
        //@formatter:on
    }

}
